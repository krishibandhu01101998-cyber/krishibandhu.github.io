<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Krishibandhu — Smart Farming Dashboard</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- TensorFlow.js (for disease model & numeric models) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>

  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:0; background:#0f1724; color:#e6eef8}
    header{padding:18px;background:#0b1220;display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:18px}
    .container{padding:18px;max-width:1200px;margin:0 auto}
    .row{display:flex;gap:18px;flex-wrap:wrap}
    .card{background:#0b1220;border-radius:10px;padding:14px;flex:1;min-width:280px;box-shadow:0 6px 18px rgba(0,0,0,.6)}
    label,input,select,button{font-size:14px}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    canvas{background:#071020;border-radius:8px;padding:8px}
    .latest{display:flex;gap:12px;flex-wrap:wrap}
    .latest div{background:#06111a;padding:8px;border-radius:6px;min-width:120px}
    .lang{margin-left:auto}
    .small{font-size:13px;color:#98a8b9}
    .uploader{display:flex;gap:8px;align-items:center}
    .recommend{margin-top:10px;background:#071826;padding:10px;border-radius:8px}
    #status{font-weight:600}
  </style>
</head>
<body>
  <header>
    <h1 id="title">Krishibandhu — Smart Farming Dashboard</h1>
    <div class="lang">
      <select id="langSelect" title="Language"><option value="en">English</option><option value="hi">हिन्दी</option><option value="bn">বাংলা</option></select>
    </div>
  </header>

  <div class="container">
    <div class="row">
      <div class="card" style="flex:2">
        <div class="controls">
          <label for="sampleSelect" class="small" id="samplesLabel">Samples:</label>
          <select id="sampleSelect">
            <option value="100">Last 100</option>
            <option value="200">Last 200</option>
            <option value="500">Last 500</option>
            <option value="1000">Last 1000</option>
          </select>

          <button id="btnRefresh">Refresh</button>
          <button id="btnCSV">Download CSV</button>

          <label class="small">Auto-predict when no data</label>
          <input type="checkbox" id="autoPredict" checked />

          <div style="margin-left:auto" class="small" id="status">Status: idle</div>
        </div>

        <hr style="opacity:.08"/>

        <div class="latest" id="latestValues" aria-live="polite"></div>

        <hr style="opacity:.08"/>

        <canvas id="chartTemp" height="140"></canvas>
        <canvas id="chartRain" height="140" style="margin-top:18px"></canvas>
        <canvas id="chartHum" height="140" style="margin-top:18px"></canvas>
        <canvas id="chartSoil" height="140" style="margin-top:18px"></canvas>

      </div>

      <div class="card" style="flex:1;min-width:320px">
        <h3 id="imgTitle">Rice Leaf Disease Detection</h3>
        <div class="small" id="imgDesc">Upload or capture an image. A pretrained TF.js model (model.json) must be in /model_for_github/model/leaf_tfjs/</div>

        <div class="uploader" style="margin-top:10px">
          <input id="imgInput" accept="image/*" type="file" />
          <button id="btnCam">Use Camera</button>
        </div>

        <div style="margin-top:10px">
          <img id="preview" alt="preview" style="max-width:100%;border-radius:8px;margin-top:8px"/>
        </div>

        <div style="margin-top:10px">
          <button id="btnPredictModel">Load Model & Predict</button>
          <div id="predictionResult" class="small" style="margin-top:10px"></div>
        </div>

        <hr style="opacity:.08"/>

        <h4 id="recommendTitle">Recommendations</h4>
        <div id="recommendations" class="recommend small"></div>

        <hr style="opacity:.08"/>

        <div class="small">Data source: ThingsBoard device telemetry</div>
        <div class="small" id="note"></div>
      </div>
    </div>
  </div>

<script>
/* ========== CONFIG ========== */
/* Replace the token in CONFIG.TB_JWT in your local copy (do not push tokens publicly) */
const CONFIG = {
  TB_HOST: "https://demo.thingsboard.io",
  TB_DEVICE_ID: "e55ec190-87b8-11f0-a9b5-792e2194a5d4",
  TB_JWT: "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJkZWJhcnBpdGFfcGhkMjJAaWlpdGthbHlhbmkuYWMu"
          + "aW4iLCJ1c2VySWQiOiJlOTFkM2MxMC03Njk0LTExZjAtOTFjYi1mNWM2NTRkNTVkMDMiLCJzY29wZXMi"
          + "OlsiVEVOQU5UX0FETUlOIl0sInNlc3Npb25JZCI6Ijg5MmQ5MjBlLTY4MzItNGUyNy04ZTY2LWIzYmZh"
          + "Yjk2ZmQ5YSIsImV4cCI6MTc1ODY4MzcxNSwiaXNzIjoidGhpbmdzYm9hcmQuaW8iLCJpYXQiOjE3NTY4"
          + "ODM3MTUsImZpcnN0TmFtZSI6IkRlYmFycGl0YSBQYXVsIiwibGFzdE5hbWUiOiJDaG91ZGh1cnkiLCJl"
          + "bmFibGVkIjp0cnVlLCJwcml2YWN5UG9saWN5QWNjZXB0ZWQiOnRydWUsImlzUHVibGljIjpmYWxzZSwi"
          + "dGVuYW50SWQiOiJlOGZlYjc5MC03Njk0LTExZjAtOTFjYi1mNWM2NTRkNTVkMDMiLCJjdXN0b21lcklk"
          + "IjoiMTM4MTQwMDAtMWRkMi0xMWIyLTgwODAtODA4MDgwODA4MDgwIn0._AvSn7GoL1c-XVZlocJgTfD734"
          + "HRPBcEnBwMR88TevuNnubQRO3tJc6UDmpgl_bHjICj-d0tZMCy2TVJjIPapQ"
};
const KEYS = ["temperature", "rainrate", "humidity", "soil_moisture"];

/* Add mapping for ThingsBoard prediction keys (update if your TB uses different names) */
const PRED_KEYS = {
  temperature: "temperature_predicted",
  rainrate:    "rainrate_predicted",
  humidity:    "humidity_predicted",
  soil_moisture: "soil_moisture_predicted"
};
/* ========== i18n ========== */
const STR = {
  en: {
    title: "Krishibandhu — Smart Farming Dashboard",
    samplesLabel: "Samples:",
    statusIdle: "Status: idle",
    statusLoading: "Status: loading...",
    predictionLoading: "Loading model...",
    recommendTitle:"Recommendations",
    note: "If ThingsBoard blocks CORS, configure a small proxy or host the site where requests allowed.",
    imgTitle:"Rice Leaf Disease Detection",
    imgDesc:"Upload or capture an image. A TF.js model must be in model_for_github/model/leaf_tfjs/"
  },
  hi: { title:"कृषिबंधु — स्मार्ट फ़ार्मिंग डैशबोर्ड", samplesLabel:"नमूने:", statusIdle:"स्थिति: निष्क्रिय", statusLoading:"स्थिति: लोड हो रही...", predictionLoading:"मॉडल लोड हो रहा है...", recommendTitle:"सुझाव", note:"यदि ThingsBoard CORS अवरुद्ध करता है, तो एक छोटा प्रॉक्सी कॉन्फिगर करें।", imgTitle:"धान पत्ता रोग पहचान", imgDesc:"इमेज अपलोड करें या कैप्चर करें। TF.js मॉडल model_for_github/model/leaf_tfjs/ में रखें।" },
  bn: { title:"Krishibandhu — স্মার্ট ফার্মিং ড্যাশবোর্ড", samplesLabel:"নমুনা:", statusIdle:"স্ট্যাটাস: নিষ্ক্রিয়", statusLoading:"স্ট্যাটাস: লোড হচ্ছে...", predictionLoading:"মডেল লোড হচ্ছে...", recommendTitle:"প্রস্তাবনা", note:"যদি ThingsBoard CORS ব্লক করে, একটি প্রোক্সি ব্যবহার করুন।", imgTitle:"ধান পাতা রোগ সনাক্তকরণ", imgDesc:"ছবি আপলোড বা ক্যাপচার করুন। TF.js মডেল model_for_github/model/leaf_tfjs/ এ রাখুন।" }
};

/* ========== DOM elements ========== */
const statusEl = document.getElementById('status');
const latestEl = document.getElementById('latestValues');
const sampleSelect = document.getElementById('sampleSelect');
const btnRefresh = document.getElementById('btnRefresh');
const btnCSV = document.getElementById('btnCSV');
const autoPredictEl = document.getElementById('autoPredict');
const langSelect = document.getElementById('langSelect');
const recommendEl = document.getElementById('recommendations');
const noteEl = document.getElementById('note');
const titleEl = document.getElementById('title');
const samplesLabel = document.getElementById('samplesLabel');
const imgInput = document.getElementById('imgInput');
const preview = document.getElementById('preview');
const btnPredictModel = document.getElementById('btnPredictModel');
const predictionResult = document.getElementById('predictionResult');
const btnCam = document.getElementById('btnCam');
const imgTitle = document.getElementById('imgTitle');
const imgDesc = document.getElementById('imgDesc');
const recommendTitle = document.getElementById('recommendTitle');

/* Charts */
let chartTemp, chartRain, chartHum, chartSoil;
function makeChart(ctx, label) {
  return new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [
      { label: label+' (Actual)', data: [], fill:false, tension:0.2, borderWidth:2 },
      { label: label+' (Predicted)', data: [], fill:false, tension:0.2, borderDash:[6,4], borderWidth:2 }
    ]},
    options: { responsive:true, interaction:{mode:'index',intersect:false}, plugins:{legend:{position:'top'}} }
  });
}

/* ---------- Startup: load charts and then models + initial data ---------- */
window.addEventListener('load', () => {
  chartTemp = makeChart(document.getElementById('chartTemp').getContext('2d'), 'Temperature (°C)');
  chartRain = makeChart(document.getElementById('chartRain').getContext('2d'), 'Rain Rate (mm/hr)');
  chartHum  = makeChart(document.getElementById('chartHum').getContext('2d'), 'Humidity (%)');
  chartSoil = makeChart(document.getElementById('chartSoil').getContext('2d'), 'Soil Moisture');
  applyLang('en');

  // Attempt to load models, then run the initial fetch+predict and start polling
  loadAllModels().then(() => {
    refreshAll_andPlot().catch(e => console.error("initial refresh error", e));
    startAutoPolling();
  });
});

/* ========== Model candidate paths (match your repo layout) ========== */
const MODEL_PATHS = {
  leaf: [
    "./model_for_github/model/leaf_tfjs/model.json",
    "/model_for_github/model/leaf_tfjs/model.json"
  ],
  temperature: [
    "./model_for_github/temperature/model.json",
    "./model_for_github/temperature/group1-shard1of1.bin"
  ],
  humidity: [
    "./model_for_github/humidity/model.json"
  ],
  rain: [
    "./model_for_github/rainMmHr/model.json"
  ],
  soil: [
    "./model_for_github/soilMoisture/model.json"
  ]
};

/* loaded models map */
const MODELS = { leaf: null, temperature: null, humidity: null, rain: null, soil: null };

/* helper: set status text */
function setStatus(txt) { statusEl.textContent = txt; }

async function tryLoadFromCandidates(candidates, friendlyName) {
  for (const url of candidates) {
    try {
      setStatus(`Trying ${friendlyName} model: ${url}`);
      const m = await tf.loadLayersModel(url);
      setStatus(`${friendlyName} model loaded`);
      console.log(`Loaded ${friendlyName} model from`, url);
      return m;
    } catch (e) {
      console.warn(`Failed to load ${friendlyName} from ${url}:`, e);
    }
  }
  setStatus(`${friendlyName} model not found in candidates`);
  return null;
}

async function loadAllModels() {
  MODELS.leaf = await tryLoadFromCandidates(MODEL_PATHS.leaf, "Leaf");
  MODELS.temperature = await tryLoadFromCandidates(MODEL_PATHS.temperature, "Temperature");
  MODELS.humidity = await tryLoadFromCandidates(MODEL_PATHS.humidity, "Humidity");
  MODELS.rain = await tryLoadFromCandidates(MODEL_PATHS.rain, "Rain");
  MODELS.soil = await tryLoadFromCandidates(MODEL_PATHS.soil, "Soil");
  const loaded = Object.entries(MODELS).filter(([,v])=>v).map(([k])=>k);
  setStatus(loaded.length ? `Models loaded: ${loaded.join(", ")}` : "No TFJS models loaded (using fallback predictors).");
}

/* ========== ThingsBoard fetch & local prediction ========== */
async function fetchTelemetry(limit=100) {
  setStatus(STR[langSelect.value].statusLoading || "Loading...");
  try {
    const keys = KEYS.join(',');
    const url = `${CONFIG.TB_HOST}/api/plugins/telemetry/DEVICE/${CONFIG.TB_DEVICE_ID}/values/timeseries?keys=${encodeURIComponent(keys)}&limit=${limit}`;
    const res = await fetch(url, { headers: { "Authorization": CONFIG.TB_JWT }});
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    setStatus(STR[langSelect.value].statusIdle || "Idle");
    return data;
  } catch (e) {
    console.error('fetchTelemetry error', e);
    setStatus('Failed to load — check CORS / token');
    return null;
  }
}

function normalizeData(tsObj) {
  const map = new Map();
  for (const k of KEYS) {
    const arr = tsObj[k] || [];
    for (const item of arr) {
      const t = item.ts;
      if (!map.has(t)) map.set(t, { ts: t });
      map.get(t)[k] = Number(item.value);
    }
  }
  const arr = Array.from(map.values()).sort((a,b)=>a.ts-b.ts);
  return arr.map(r=> ({...r, time: new Date(r.ts).toLocaleString()}));
}

/* ---------- NEW: Actual vs Predicted logic ---------- */

const POLL_MS = 15 * 60 * 1000; // 15 minutes (change for testing)
const PREDICT_HORIZON = 96;     // how many future steps to predict

function buildActualArrays(normData) {
  const actualByKey = {};
  for (const k of KEYS) actualByKey[k] = normData.map(r => (r[k] === undefined ? null : Number(r[k])));
  const labels = normData.map(r => r.time);
  return { actualByKey, labels };
}

function linearPredictFromLast(normData, key, horizon) {
  const series = normData.map(r => (r[key] === undefined ? null : Number(r[key])));
  const history = series.filter(v => v !== null).slice(-6);
  const preds = [];
  if (history.length === 0) {
    for (let i=0;i<horizon;i++) preds.push(0);
    return preds;
  }
  if (history.length === 1) {
    for (let i=0;i<horizon;i++) preds.push(history[0]);
    return preds;
  }
  const x = history.map((_,i)=>i+1);
  const y = history;
  const n = x.length;
  const sumX = x.reduce((a,b)=>a+b,0), sumY = y.reduce((a,b)=>a+b,0);
  const sumXY = x.reduce((a,b,i)=>a + b*y[i],0), sumX2 = x.reduce((a,b)=>a + b*b,0);
  const denom = n*sumX2 - sumX*sumX;
  const slope = denom === 0 ? 0 : (n*sumXY - sumX*sumY)/denom;
  const intercept = (sumY - slope*sumX)/n;
  for (let i=1;i<=horizon;i++) preds.push(intercept + slope*(n+i));
  return preds;
}

async function computePredictedSeries(normData) {
  const { actualByKey, labels } = buildActualArrays(normData);
  const last = normData.length ? normData[normData.length-1] : null;
  const horizon = Math.min(PREDICT_HORIZON, 96);

  const predictedByKey = {};
  for (const k of KEYS) predictedByKey[k] = new Array(normData.length).fill(null);

  const canUseTFJS = (k) => !!MODELS[k];

  let intervalMs = 15*60*1000;
  if (normData.length > 1) intervalMs = normData[normData.length-1].ts - normData[normData.length-2].ts;
  const futureTimestamps = [];
  let lastTs = normData.length ? normData[normData.length-1].ts : Date.now();
  for (let i=1;i<=horizon;i++) { lastTs += intervalMs; futureTimestamps.push({ ts: lastTs, time: new Date(lastTs).toLocaleString() }); }

  for (const key of KEYS) {
    if (canUseTFJS(key)) {
      try {
        let lastValue = (last && last[key] !== undefined) ? Number(last[key]) : 0;
        const preds = [];
        for (let i=0;i<horizon;i++) {
          // adapt tensor shape if your model expects different input
          const inputTensor = tf.tensor2d([[ lastValue ]], [1, 1]);
          let out = MODELS[key].predict(inputTensor);
          if (Array.isArray(out)) out = out[0];
          const arr = await out.data();
          const nextVal = Number(arr[0]);
          preds.push(nextVal);
          lastValue = nextVal;
          inputTensor.dispose(); if (out.dispose) out.dispose();
        }
        for (let i=0;i<horizon;i++) predictedByKey[key].push(preds[i]);
      } catch (e) {
        console.warn("TFJS predict failed for", key, e);
        const fallback = linearPredictFromLast(normData, key, horizon);
        for (let i=0;i<horizon;i++) predictedByKey[key].push(fallback[i]);
      }
    } else {
      const fallback = linearPredictFromLast(normData, key, horizon);
      for (let i=0;i<horizon;i++) predictedByKey[key].push(fallback[i]);
    }
  }

  const combinedLabels = labels.slice();
  for (const f of futureTimestamps) combinedLabels.push(f.time);

  return { predictedByKey, combinedLabels, horizon };
}

/* ---------- REPLACED: refreshAll_andPlot that also loads TB-side predictions when no actuals ---------- */
async function refreshAll_andPlot() {
  const limit = Number(sampleSelect.value);
  const raw = await fetchTelemetry(limit);

  // If we have actual telemetry data, proceed as before
  if (raw) {
    const norm = normalizeData(raw);
    if (norm && norm.length > 0) {
      // we have actuals — compute predicted tail and plot
      setStatus("Computing predictions for actual data...");
      const { predictedByKey, combinedLabels, horizon } = await computePredictedSeries(norm);
      // pad actual arrays to match combinedLabels and update charts
      const actualByKey = {};
      for (const k of KEYS) {
        const arr = norm.map(r => (r[k] === undefined ? null : Number(r[k])));
        for (let i=0;i<horizon;i++) arr.push(null);
        actualByKey[k] = arr;
      }
      // update latest panel with last actual
      latestEl.innerHTML = '';
      const last = norm.length ? norm[norm.length-1] : null;
      for (const key of KEYS) {
        const v = last && last[key] !== undefined ? last[key].toFixed(3) : '—';
        const div = document.createElement('div');
        div.innerHTML = `<div class="small">${key}</div><div style="font-weight:600">${v}</div>`;
        latestEl.appendChild(div);
      }
      // update charts
      function updateChart(ch, key) {
        ch.data.labels = combinedLabels;
        ch.data.datasets[0].data = actualByKey[key];
        ch.data.datasets[1].data = predictedByKey[key];
        ch.update();
      }
      updateChart(chartTemp, 'temperature');
      updateChart(chartRain, 'rainrate');
      updateChart(chartHum, 'humidity');
      updateChart(chartSoil, 'soil_moisture');

      // recommendations (same as before)
      const rc = [];
      if (last) {
        const t = last.temperature; if (t !== undefined && t !== null) { if (t > 35) rc.push("High temperature: consider irrigation and shading."); else if (t < 18) rc.push("Low temperature: monitor seedling heat protection."); }
        if (last.humidity !== undefined && last.humidity > 80) rc.push("High humidity: risk of fungal disease. Check leaves.");
        if (last.rainrate !== undefined && last.rainrate > 10) rc.push("Heavy rain: protect crops from water logging.");
      }
      recommendEl.innerHTML = rc.length ? rc.map(x=>`• ${x}`).join("<br>") : "No specific recommendations.";
      window._lastFetched = { norm, predictedByKey, combinedLabels };
      setStatus("Updated actual vs predicted (last run).");
      return;
    }
  }

  // --- No actual telemetry available: try to fetch predicted telemetry keys from ThingsBoard ---
  setStatus("No recent actual telemetry — attempting to load predictions from ThingsBoard...");
  try {
    // construct keys string from PRED_KEYS values
    const predKeysList = Object.values(PRED_KEYS).map(k => encodeURIComponent(k)).join(',');
    const url = `${CONFIG.TB_HOST}/api/plugins/telemetry/DEVICE/${CONFIG.TB_DEVICE_ID}/values/timeseries?keys=${predKeysList}&limit=${limit}`;
    const res = await fetch(url, { headers: { "Authorization": CONFIG.TB_JWT }});
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const predRaw = await res.json();
    // normalize predicted telemetry (same shape expected: arrays of {ts,value})
    // build records from predRaw
    const map = new Map();
    // map predicted keys back to KEYS: find which TB key maps to which metric
    for (const k of KEYS) {
      const tbKey = PRED_KEYS[k];
      const arr = predRaw[tbKey] || [];
      for (const item of arr) {
        const t = item.ts;
        if (!map.has(t)) map.set(t, { ts: t });
        map.get(t)[k] = Number(item.value);
      }
    }
    const predArr = Array.from(map.values()).sort((a,b)=>a.ts-b.ts).map(r=> ({...r, time: new Date(r.ts).toLocaleString()}));

    if (predArr.length > 0) {
      // we have TB-side predictions — plot them (no actuals)
      const labels = predArr.map(r=>r.time);
      const predictedByKey = {};
      const actualByKey = {};
      for (const k of KEYS) {
        predictedByKey[k] = predArr.map(r => r[k] === undefined ? null : Number(r[k]));
        // actual series will be nulls since none present
        actualByKey[k] = new Array(predictedByKey[k].length).fill(null);
      }
      // update latest panel showing most recent predicted values
      latestEl.innerHTML = '';
      const lastPred = predArr.length ? predArr[predArr.length-1] : null;
      for (const key of KEYS) {
        const v = lastPred && lastPred[key] !== undefined ? lastPred[key].toFixed(3) : '—';
        const div = document.createElement('div');
        div.innerHTML = `<div class="small">${key}</div><div style="font-weight:600">${v}</div>`;
        latestEl.appendChild(div);
      }
      // update charts (actual dataset will be null series)
      function updateChart(ch, key) {
        ch.data.labels = labels;
        ch.data.datasets[0].data = actualByKey[key];
        ch.data.datasets[1].data = predictedByKey[key];
        ch.update();
      }
      updateChart(chartTemp, 'temperature');
      updateChart(chartRain, 'rainrate');
      updateChart(chartHum, 'humidity');
      updateChart(chartSoil, 'soil_moisture');

      recommendEl.innerHTML = "Predicted values shown (no actual telemetry).";
      window._lastFetched = { norm: [], predictedByKey, combinedLabels: labels };
      setStatus("Showing predictions from ThingsBoard.");
      return;
    }
  } catch (e) {
    console.warn("Failed to load predicted telemetry from ThingsBoard:", e);
  }

  // --- If we reach here: ThingsBoard had no predictions (or request failed) ---
  // Fallback: use last computed predictions in memory (if available)
  if (window._lastFetched && window._lastFetched.predictedByKey) {
    setStatus("No current telemetry. Using last in-memory predictions.");
    const predictedByKey = window._lastFetched.predictedByKey;
    const combinedLabels = window._lastFetched.combinedLabels || [];
    const actualByKey = {};
    for (const k of KEYS) actualByKey[k] = new Array(combinedLabels.length).fill(null);
    function updateChart(ch, key) {
      ch.data.labels = combinedLabels;
      ch.data.datasets[0].data = actualByKey[key];
      ch.data.datasets[1].data = predictedByKey[key];
      ch.update();
    }
    updateChart(chartTemp, 'temperature');
    updateChart(chartRain, 'rainrate');
    updateChart(chartHum, 'humidity');
    updateChart(chartSoil, 'soil_moisture');

    // show most recent predicted values in latest panel
    latestEl.innerHTML = '';
    const lastPredVal = (() => {
      const kb = predictedByKey;
      if (!kb) return null;
      const anyKey = KEYS[0];
      const arr = kb[anyKey] || [];
      const lastIdx = arr.length - 1;
      if (lastIdx < 0) return null;
      const rec = {};
      for (const k of KEYS) rec[k] = (kb[k] && kb[k][lastIdx] !== undefined) ? kb[k][lastIdx] : null;
      return rec;
    })();
    for (const key of KEYS) {
      const v = lastPredVal && lastPredVal[key] !== null ? lastPredVal[key].toFixed(3) : '—';
      const div = document.createElement('div');
      div.innerHTML = `<div class="small">${key}</div><div style="font-weight:600">${v}</div>`;
      latestEl.appendChild(div);
    }

    recommendEl.innerHTML = "Showing last in-memory predictions (no telemetry).";
    setStatus("Displayed cached predictions.");
    return;
  }

  // final fallback: nothing to show
  setStatus("No telemetry or predictions available.");
  latestEl.innerHTML = '';
  recommendEl.innerHTML = "No data available.";
  // clear charts
  function clearChart(ch) { ch.data.labels = []; ch.data.datasets[0].data = []; ch.data.datasets[1].data = []; ch.update(); }
  clearChart(chartTemp); clearChart(chartRain); clearChart(chartHum); clearChart(chartSoil);
}

let pollHandle = null;
function startAutoPolling() {
  if (pollHandle) clearInterval(pollHandle);
  pollHandle = setInterval(() => {
    refreshAll_andPlot().catch(e => console.error("refresh error", e));
  }, POLL_MS);
}

/* CSV download (unchanged) */
function generateCSV(data, preds) {
  const rows = [];
  const headers = ["time"];
  for (const k of KEYS) {
    headers.push(`${k}_actual`);
    headers.push(`${k}_predicted`);
  }
  rows.push(headers.join(','));
  const predMap = new Map((preds||[]).map(p=>[p.ts, p]));
  const allTimes = new Set([...(data||[]).map(d=>d.ts), ...(preds||[]).map(p=>p.ts)]);
  const timesSorted = Array.from(allTimes).sort((a,b)=>a-b);
  for (const t of timesSorted) {
    const recAct = (data||[]).find(r=>r.ts===t) || {};
    const recPred = predMap.get(t) || {};
    const timeStr = new Date(t).toLocaleString();
    const cells = [timeStr];
    for (const k of KEYS) {
      cells.push(recAct[k] !== undefined ? recAct[k] : '');
      cells.push(recPred[k] !== undefined ? recPred[k] : '');
    }
    rows.push(cells.join(','));
  }
  return rows.join('\n');
}

btnCSV.addEventListener('click', ()=> {
  const s = window._lastFetched;
  if (!s) return alert('No data fetched');
  // We do not include predictedByKey here in original CSV schema; you can adapt if you want full predicted series
  const csv = generateCSV(s.norm, s.preds || []);
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'krishibandhu_data.csv'; a.click(); URL.revokeObjectURL(url);
});

/* refresh button */
btnRefresh.addEventListener('click', refreshAll_andPlot);

/* language */
function applyLang(code) {
  document.getElementById('title').textContent = STR[code].title;
  document.getElementById('samplesLabel').textContent = STR[code].samplesLabel;
  noteEl.textContent = STR[code].note;
  imgTitle.textContent = STR[code].imgTitle;
  imgDesc.textContent = STR[code].imgDesc;
  recommendTitle.textContent = STR[code].recommendTitle;
  setStatus(STR[code].statusIdle);
}
langSelect.addEventListener('change', e => applyLang(e.target.value));

/* image preview & camera */
imgInput.addEventListener('change', e => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  preview.src = URL.createObjectURL(f); preview.dataset.blob = f;
});
btnCam.addEventListener('click', ()=> {
  const capture = document.createElement('input');
  capture.type='file'; capture.accept='image/*'; capture.capture='environment';
  capture.onchange = (e) => { const f = e.target.files && e.target.files[0]; if (!f) return; preview.src = URL.createObjectURL(f); preview.dataset.blob = f; };
  capture.click();
});

/* Load leaf model and predict on uploaded image */
const LEAF_LABELS = ["Healthy","Blast","Bacterial Blight","Brown Spot"]; // replace with your labels if different

btnPredictModel.addEventListener('click', async () => {
  if (!preview.src) { alert('Upload or capture an image first'); return; }
  setStatus(STR[langSelect.value].predictionLoading || "Loading model...");
  if (!MODELS.leaf) {
    MODELS.leaf = await tryLoadFromCandidates(MODEL_PATHS.leaf, "Leaf");
    if (!MODELS.leaf) { setStatus("Leaf model not found. Check model_for_github/model/leaf_tfjs/"); return; }
  }
  try {
    const imgEl = document.createElement('img');
    imgEl.src = preview.src;
    await imgEl.decode();
    const INPUT_SIZE = 224; // change if your model expects different size
    const t = tf.browser.fromPixels(imgEl).resizeNearestNeighbor([INPUT_SIZE,INPUT_SIZE]).toFloat().div(tf.scalar(255.0)).expandDims(0);
    let preds = MODELS.leaf.predict(t);
    if (Array.isArray(preds)) preds = preds[0];
    const probs = Array.from(await preds.data());
    const topIdx = probs.indexOf(Math.max(...probs));
    predictionResult.innerHTML = `Prediction: <b>${LEAF_LABELS[topIdx] || ("Class " + topIdx)}</b> — ${(probs[topIdx]*100).toFixed(1)}%`;
    t.dispose();
    if (preds.dispose) preds.dispose();
    setStatus(STR[langSelect.value].statusIdle);
  } catch (e) {
    console.error(e);
    setStatus("Prediction error (see console).");
    predictionResult.textContent = "Prediction failed: " + (e.message || e);
  }
});

/* initial note */
noteEl.textContent = STR.en.note;
</script>
</body>
</html>
